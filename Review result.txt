- All properties in your control must be dependency properties.
  'INotifyPropertyChanged' is only for types that don't extend 'DependencyObject'.
  The performance of dependency properties is superior 
  as it doesn't require the binding engine to use reflection in order to resolve the property.
  Dependency properties also enable flexibility for the client in terms of customization and handling.
  For example, you can only set a 'Binding' on a dependency property or animate it.
  Use code templates for convenient creation: type "prop" and select "propdp" and pres TAB twice to insert the generated code and  beginn editing the snippet.
- Use TemplateBinding in ControlTemplates when possibble
- Use routed commads in controls. Routed events are specialized 'ICommand' implementations 
  that add convenience and flexibility in terms of UI code design 
  opposed to normal ICommands without routing ability.
- Separate local control related resource keys from global resource keys,
  Means, in your case WackyWidget must only define resource keys for it internal style overrides.
  Resources like colors and brushes or layout constants like thickness or padding should be defined in a separate class.
  Such a class makes it clear for other control authors that those resource keys and their associated resources are global.
  I introduced such a static class to highlight the benefits.
- Your RelayCommand implementation is almost useless in termes of its generic nature.
  Generic types add type safety in contrast to variables or parameters of type 'object'.
  But then you must use the generic type parameter in all the type's API. For example, your Execute and CanExecute still declare their parameters of type 'object'.
  To satisfy the interface (which requires the parameters to be of type 'object') and the generic type parameters you must implement the non generic interface explicitly 
  and delegate the implementation to the generic typed implementations.  
  Then to support a void parameter RelayCommand (parameterless Execute and CanExecute) you must implement a second non generic version. This non-generic version must also implement ICommand explicitly 
  and delegate the Icommand.Execute(object) to the RelayCommand.Execute(void).
  Please see the new RelayCommand<T> implementation in the /Generic folder and the non-generic implementation, especially Execute and CanExecute, 
  to understand whast I mean. 
  And check how the usage inside the WackyWidget and AnotherWackyWidget controls has changed to the better
- The way you initialize the ICommand properties in WackyWidget is very ugly and smelly. Better move the initialization to the constructor.
  This also eliminates the backing field - and the redundant NULL check. This NULL check is only relevant for the first time but will produce a constant cost.
- In the command context you should consider to use a different naming. Member names are very important, not only for others, but for yourself. 
  Looking at code that is a half year old can feel like looking at code written by a strager. Good names help to understand your own code after time passed by.
  For example, teh past tense form is usually reserved for events. 'SearchExecuted' communictes to be a command.
  This name makes sense for the handler of a RoutedCommand as routed commands are routed events underneath wrapped behind the ICommand interface.
  But in the case of WackWidget 'SearchExecuted' and 'SearchCanExecute' are methods and not event handlers. So the correct names would be 'ExecuteSearchCommand' (or 'ExecuteSearch') and 'CanExecuteSearchCommand' (or 'CanExecuteSearch').
  I prefer the Command suffix. For example, 'ExecuteSearchCommand' could do something with the command parameter 
  and then finally call 'Search'. Like event invocators and event handlers, command handlers should not be called by instance or class code but they must delegate work by calling instance or class methods.
  This way you can seperate contexts and don't have to provide redundant arguments to a method just because the boundary dictates it.
  For example, the signature of an event handler is dictated by the event delegate: 'OnSomeEventHappened(object sender, EventArgs e)'.
  It would be smelly to call `OnSomeEventHappened` from instance context because you would have to provide a 'sender' and an 'EventArgs' object
  only to execute the functionality. So you view the event handler as a special purpose member that must be separated from the type members 
  by moving the functionality toa member method that is
  reasonable to use: 'OnSomeEventHappened(object sender, EventArgs e) => DoSomethin();'. Now DoSomething can be used by instance code without providing redundant parameters.
  The same principle applies to command handlers. 
  Add an extra layer to decouple the signature imposed by the commanding infrastructure 
  by invoking the actual functionality via delegation:
  'ExecuteSearchCommand(object commandParameter) => Search(commandParameter as string);'. 
  The 'Command' prefix in the method name makes the purpose of the method clear: it's a special purpose method that must not be called directly.
  It is called by a certain infrastructure as part of a contract (interface).
- Speaking of naming conventions, in C# field names are always camelCase. So '_SearchCommand' must be '_searchCommand' or '_Results' must be '_results'.
  Names are important so is casing. Especially when you share code with others. 
  It helps everybody to feel at home and not being distracted by formatting or casing, 
  so that we can focus on understanding the code. Maybe this is the convention you are used to because it is used in your company.
  99.99999% of C# developers follow the official Microsoft C# naming guideline. This makes it easier for everybody.
  Capitalization Conventions: https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/capitalization-conventions
  Naming guidelines: https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines
  Framework design guidelines: https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/

  Thanks for reading :)
  Have a good time!

  Don't forget to read the "Theme_Resources_Naming_Conventions.txt" (repo root folder)
  and the in code comments.
  

